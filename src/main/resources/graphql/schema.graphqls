type Query {
    # Availability queries
    availabilitySlots(propertyId: ID!, from: String, to: String): [AvailabilitySlot!]!

    # Booking queries
    booking(id: ID!): Booking
    bookings(filter: BookingFilter): [Booking!]!
    calendar(propertyId: ID!, from: String!, to: String!): CalendarView!

    # Visit queries
    visit(id: ID!): Visit
    visits(filter: VisitFilter): [Visit!]!
    visitsByProperty(propertyId: ID!): [Visit!]!
    visitsByVisitor(visitorId: ID!): [Visit!]!
    visitsByLandlord(landlordId: ID!): [Visit!]!

    # Dashboard analytics queries - ADDED
    tenantDashboardStats(tenantId: ID!): DashboardStats!
    landlordDashboardStats(landlordId: ID!): DashboardStats!

    # User queries - can be expanded based on needs
    tenant(id: ID!): User
    landlord(id: ID!): User
}

type Mutation {
    # Availability mutations
    createAvailabilitySlot(input: AvailabilitySlotInput!): AvailabilitySlot!
    deleteAvailabilitySlot(id: ID!): Boolean!

    # Booking mutations
    createBooking(input: BookingInput!): Booking!
    acceptBooking(id: ID!): Booking!
    rejectBooking(id: ID!): Booking!
    cancelBooking(id: ID!): Booking!
    rescheduleBooking(id: ID!, startDate: String!, endDate: String!): Booking!
    updateBookingPayment(
        bookingId: ID!,
        paymentStatus: PaymentStatus!,
        paymentReference: String,
        paymentAmount: Float
    ): Booking!

    # Visit mutations
    requestVisit(input: VisitInput!): Visit!
    approveVisit(id: ID!): Visit!
    rejectVisit(id: ID!): Visit!
    cancelVisit(id: ID!): Visit!
    completeVisit(id: ID!): Visit!
}

# Input types
input AvailabilitySlotInput {
    propertyId: ID!
    landlordId: ID!
    date: String!
    startTime: String!
    endTime: String!
    intervalMinutes: Int
}

input BookingInput {
    tenantId: ID!
    landlordId: ID!
    propertyId: ID!
    startDate: String!
    endDate: String!
    # Adding missing required fields from ShortletBooking model
    firstName: String!
    lastName: String!
    phoneNumber: String!
}

input VisitInput {
    propertyId: ID!
    visitorId: ID!
    landlordId: ID!
    # Changed from scheduledDate to scheduledAt to match Java model
    scheduledAt: String!
    # Adding missing fields from Visit model
    durationMinutes: Int
    notes: String
    slotId: ID
    status: VisitStatus
}

input BookingFilter {
    tenantId: ID
    landlordId: ID
    propertyId: ID
    status: BookingStatus
    fromDate: String
    toDate: String
    page: Int
    size: Int
}

input VisitFilter {
    visitorId: ID
    landlordId: ID
    propertyId: ID
    status: VisitStatus
    fromDate: String
    toDate: String
    page: Int
    size: Int
}

# Object types
type AvailabilitySlot {
    id: ID!
    propertyId: ID!
    landlordId: ID!
    startTime: String!
    endTime: String!
    booked: Boolean!
}

type Booking {
    id: ID!
    tenantId: ID!
    landlordId: ID!
    propertyId: ID!
    tenant: User
    landlord: User
    property: Property
    startDate: String!
    endDate: String!
    status: BookingStatus!
    nights: Int!
    # Adding missing fields from ShortletBooking model
    firstName: String!
    lastName: String!
    phoneNumber: String!
    paymentStatus: PaymentStatus
    paymentReference: String
    paymentAmount: Float
    reminder24hSent: Boolean!
    reminder1hSent: Boolean!
}

type Visit {
    id: ID!
    propertyId: ID!
    visitorId: ID!
    landlordId: ID!
    # Changed from scheduledDate to scheduledAt to match Java model
    scheduledAt: String
    status: VisitStatus!
    # Adding missing fields from Visit model
    durationMinutes: Int
    notes: String
    slotId: ID
    rescheduledFromId: ID
    createdAt: String
    updatedAt: String
    # Keeping scheduledDate for backward compatibility
    scheduledDate: String
}

type User {
    id: ID!
    firstName: String
    lastName: String
    email: String
    phone: String
}

type Property {
    id: ID!
    title: String
    description: String
    address: String
    imageUrl: String
}

type CalendarView {
    slots: [AvailabilitySlot!]!
    bookings: [Booking!]!
}

# Dashboard Stats type matching our DTO structure
type DashboardStats {
    totalVisits: Int
    pendingVisits: Int
    upcomingVisits: Int
    totalBookings: Int
    activeBookings: Int
    favoriteProperties: Int
    totalSpent: Float
    nextPaymentDue: String      # Date string
    nextVisitDate: String       # Date string
    visitStats: VisitStatsBreakdown
    bookingStats: BookingStatsBreakdown
}

type VisitStatsBreakdown {
    approved: Int
    rejected: Int
    completed: Int
    cancelled: Int
}

type BookingStatsBreakdown {
    confirmed: Int
    pending: Int
    completed: Int
    cancelled: Int
}

# Enums - Fixed to match Java models exactly
enum BookingStatus {
    PENDING
    ACCEPTED
    REJECTED
    CANCELLED
    RESCHEDULED
    NO_SHOW
}

# Fixed to match your Java Status enum exactly
enum VisitStatus {
    PENDING
    APPROVED
    REJECTED
    CANCELLED
    RESCHEDULED
    COMPLETED
}

enum PaymentStatus {
    PENDING
    PAID
    FAILED
}
